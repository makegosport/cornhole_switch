import uuid
import argparse
import logging.config
import re
import json
import time

import paho.mqtt.client as mqtt

class CornHoleGameSim:
    """
    Main Class

    Args:
        user_template_dir (str): Path to a directory where user-defined jinja template overrides are stored.
        user_template_context (dict): Additional context variables to load into the template namespace.

    """
    _DEFAULT_MQTT_SERVER = 'localhost'
    _DEFAULT_MQTT_SERVER_PORT = 1883

    def __init__(self, **kwargs):

        self.__logger = logging.getLogger(__name__ + '.CornHoleGameSim')

        # initialise the mqtt part of the class
        self.__my_uuid = uuid.uuid4()
        self.__mqtt_client = mqtt.Client(str(self.__my_uuid)+'_cornhole_game_sim')

        mqtt_server = kwargs.pop('mqtt_server', self._DEFAULT_MQTT_SERVER)
        if not isinstance(mqtt_server, str):
            raise TypeError(f'mqtt_server should be of type bool, got {type(mqtt_server)}')
        self.__mqtt_host = mqtt_server

        mqtt_port = kwargs.pop('mqtt_port', self._DEFAULT_MQTT_SERVER_PORT)
        if not isinstance(mqtt_port, int):
            raise TypeError(f'mqtt_server should be of type bool, got {type(mqtt_server)}')
        self.__mqtt_port = mqtt_port

    def mqtt_connect(self):
        self.__mqtt_client.connect(host=self.__mqtt_host,
                                   port=self.__mqtt_port)
        self.__mqtt_client.on_message = self.on_message  # attach function to callback
        self.__mqtt_client.subscribe("$SYS/broker/uptime")
        self.__mqtt_client.subscribe("switch/heartbeat")
        for hole in range(6):
            self.__mqtt_client.subscribe(f'switch/{hole:d}')

        self.__mqtt_client.loop_start()

    def mqtt_disconnect(self):
        self.__mqtt_client.loop_stop(force=True)

    def connect(self):
        self.mqtt_connect()

    def disconnect(self):
        self.mqtt_disconnect()

    def update_hole(self, hole_id, state:bool, colour:str):
        """
        Generate a simulated message simular to the one generated by the make_game.py _gamehole
        class

        :param hole_id: hole number
        :param state: whether the hole is active or not
        :type state: bool
        :param colour: hole colour
        :return:
        """
        self.__mqtt_client.publish(f'holes/{hole_id:d}',
                                   json.dumps({'state': state, 'colour': colour}))

    def conf_switch_debounce(self, interval:int=50, hold_off:int=3000):
        self.__mqtt_client.publish(f'switch/interval',interval, retain=True)
        self.__mqtt_client.publish(f'switch/hold_off',hold_off, retain=True)

    def on_message(self, client, userdata, message):
        message_payload = message.payload.decode('utf-8')

        topic_match = re.match(r'switch/(\d+)', message.topic)
        if topic_match is not None:
            hole_id = int(topic_match.groups()[0])

            message_payload = message.payload.decode('utf-8')

            self.__logger.info(
                f'{hole_id:d} : {message_payload}')

            return None

        if message.topic == '$SYS/broker/uptime':
            # decode the message
            decoded_re = re.match(r'(\d+) seconds', message_payload)

            if decoded_re is None:
                self.__logger.error(f'unable to decode mqtt topic: cornhole/endgame, {message_payload=}')
            else:
                mqtt_broker_uptime = int(decoded_re.groups()[0])
                self.__logger.debug(f'received an mqtt {message.topic=}, {message_payload=} : decoded {mqtt_broker_uptime=} secs')

            return None

        if message.topic == 'switch/heartbeat':
            # decode the message
            decoded_re = re.match(r'(\d+)', message_payload)

            if decoded_re is None:
                self.__logger.error(f'unable to decode mqtt topic: cornhole/endgame, {message_payload=}')
            else:
                switch_uptime = int(decoded_re.groups()[0])
                self.__logger.debug(f'received an mqtt {message.topic=}, {message_payload=} : decoded {switch_uptime=} msecs')

            return None

        self.__logger.error(f'received an unexpected mqtt {message.topic=}')

# set up the command line arguments for calling the application
parser = argparse.ArgumentParser(description='Python Code to generate a simulate the Cornhole game MQTT messages',
                                     epilog='See: https://github.com/krcb197/CheerLightTwitterAPI '
                                            'for more details')
parser.add_argument('--mqtt_server', '-a', dest='mqtt_server', type=str, default='192.168.1.142',
                    help='address for the MQTT server')
parser.add_argument('--mqtt_port', '-p', dest='mqtt_port', type=int, default=1884,
                    help='port for the MQTT server')
parser.add_argument('--verbose', '-v', dest='verbose', action='store_true',
                    help='All the logging information will be shown in the console')

if __name__ == "__main__":

    # parse the command line args
    command_args = parser.parse_args()

    # set up the logging configuration
    if command_args.verbose:
        LOGGING_CONFIG = {
            'version': 1,
            'disable_existing_loggers': True,
            'formatters': {
                'standard': {
                    'format': '%(asctime)s [%(levelname)s] %(name)s: %(message)s'
                },
            },
            'handlers': {
                'default': {
                    'level': 'DEBUG',
                    'formatter': 'standard',
                    'class': 'logging.StreamHandler',
                    'stream': 'ext://sys.stdout',  # Default is stderr
                },
            },
            'loggers': {
                '': {  # root logger
                    'handlers': ['default'],
                    'level': 'DEBUG',
                    'propagate': False
                },
                '__main__': {  # if __name__ == '__main__'
                    'handlers': ['default'],
                    'level': 'DEBUG',
                    'propagate': False
                },
                __name__ + '.CornHoleGameSim': {  # if __name__ == '__main__'
                    'handlers': ['default'],
                    'level': 'DEBUG',
                    'propagate': False
                },
            }
        }
        logging.config.dictConfig(LOGGING_CONFIG)

    game_sim = CornHoleGameSim(mqtt_port=command_args.mqtt_port,
                               mqtt_server=command_args.mqtt_server)
    game_sim.connect()

    game_sim.conf_switch_debounce(interval=150, hold_off=5000)

    while True:
        for colour in ['red',
                       'green',
                       'blue',
                       'cyan',
                       'white',
                       'oldlace',
                       'purple',
                       'magenta',
                       'yellow',
                       'orange',
                       'pink']:
            game_sim.update_hole(1, True, colour)
            time.sleep(5)
        game_sim.update_hole(1, False, 'red')
        time.sleep(5)


